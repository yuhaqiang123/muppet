  经过一个多月间断而又坎坷的开发，muppet1.4版本已经测试发布，亮点有二
	1.新增功能点：根据用户定义的实体类
		（1）、自动生成表定义。 （默认情况下，这个功能是关闭的。）
		（2）、根据用户修改，自动修改表定义。（默认情况下，这个功能是关闭的。）
		就难点而言，第二功能点更困难，需要考虑太多的细节，而且不同数据库对Sql标准的支持不同，语法也不同。甚至在某种程度上，难度的增加，导致第二功能点很大风险。（未考虑的用户修改场景，导致表定义的错误修改）
	就功能而言：第一功能点是最重要的，用户可以不用熟悉DDL语句的情况下，自动生成表定义。也是实现起来相对容易，稳妥的。	第二功能点：功能而言不是很强，用户数据库变更的情况下，首先思考的更多是操作数据库，而不是操作框架去修改数据库，毕竟通过一种媒介，去修改一种东西，会有误差，只要是媒介就是一种适配器，适配器就需要考虑细节，考虑两方面的细节，细节是容易被忽视的，但是却是能致命的。所以即使hibernate这样的框架，我相信这个功能他也不敢轻易实现，轻易保证修改的可靠性。
	功能点内部原理与难点：
		1.读取xml配置文件，解析获取实体类的包名（StandardResourceConfig） //董浩
		2.加载指定包下的类，保存在映射（Map）中(StandardResourceLoader)  //杨开
		3. 解析指定包下的所有的类，这里的解析主要是指解析实体类上的所有注解，根据框架预定义的各个注解的使用规则，优先顺序
			冲突处理，将解析结果保存起来（ResourceResolver）(Resolver解析分解)//莹莹
		4. 数据库检查，我们做的是对象向数据库表定义的映射，当然需要在解析配置，//仁鹏
		   加载资源，解析分解完毕之后拿着我们解析到的结果跟数据库进行比较
		   这个比较的重任交给了DataBaseCheck以及他的两个内部类（TableCheck,ColumnCheck）,它主要负责检查表是否存在，列是否存在，列的定义是否不同（主要检查，是否主键，是否为空，是否不同，默认值，是否索引，数据类型，数据类型的长度等）
		   如何比较呢？需要调用JDBC的API,有直接调用即可返回结果的，有的需要混合使用。我所说的细节中有四分之一都在这里
		5. Sql语句生成
		   这是最简单的一层，也是最困难的一层，关键在于你怎么实现，
		   如果你想不负责任的实现，那么你就可以实现的简单一点点，如果你想负责任的实现，你一想到使用你框架的程序员，
		   因为你的愚蠢设计和编码不停地加班，而至于癫狂，就手脚发抖，如坐针毡，深深地愧疚，以至于日日分享祷告，
		   还夜夜噩梦缠身，那么你就负责的实现,（负责的程序猿是宁可让自己癫狂，也不让代码的调用者有一丝烦恼的测试猿）
		   这个层主要由Generate接口负责，其下有很多实现类AlterColumnGenerate,AlterAddColumnGenerate,AlterColumnPrimaryKeyGenerate,TableGenerate
		   分别实现生成列修改语句，列添加语句，修改主键语句，表语句生成。
		6.执行生成的Sql语句，通过Statement执行
		7.异常信息的有效反馈，从一开始muppet就把有效的异常反馈放在首位，让调用者清晰为何出现了错误，少打印一些无效的异常信息，这些异常信息，会	干扰程序员对bug位置的判断。
		但是在这个过程里也遇到了相当大的困难，我们定义了InitException，这个异常是所有异常基类，属于运行期异常，不需要显示捕获，但是如果出错，没有遇到异常处理，会导致程序终止。之前的设计基于模板方法模式，在方法调用层次浅的情况下，表现良好，在方法调用层次高于七级，八级之后，会产生混乱，1.4版本对于异常处理提出了更高的要求，对于异常体系的设计也提出了要求，1.4版本会继续优化异常信息反馈
		8。日志信息反馈。在以往的版本中，muppet并没有日志管理，对于输出也是Sysout，System类的公有属性out是一个PrintStream类型静态常量，他的println方法是一个同步方法，对本对象同步，而且本身I/O操作就很费时，在大量调用后，更导致系统性能下降，所以，再上线，之后，应该杜绝一行与业务无关的System.out.println的运行。所以我们封装了一个Logger类，实现简单的输出，方法内有一个boolean参数可以控制日志输出。
	
	
   2.设计理念的变化：工具类的设计向容器设计的转变 		    1.4版本主要功能添加实体类映射为表对象，但是实体类映射为表对象难度较大，难以实现多数据库平台的迁移，且实用性不强但是1.4版本体现了了容器的设计，改变以往工具类的设计思想，工具类的设计简单易于实现，使用方便，将muppet定义为工具类有若干好处，例如使用简单，高效，容易管理，但同时也限制了muppet的发展，例如扩展性，容器的设计思想更能体现面向对象，通过对象的生命周期，对象的组合关系，继承关系更好的扩展系统，而基于工具类的设计，因为静态类在用户未启动的可以访问系统的内部结构，导致系统对象的状态失效，造成失败的调用，这种场景调用太过于复杂，系统的封闭性不够。使用容器的设计，可在对象的创建上做限制，可以要求必需的数据结构，可以保证对象的状态始终处于有效状态。
		3.容器的设计
			了解一个框架，一个软件，一个组件的方式无怪乎，两点
			数据结构与算法
			下面引用陈涛在《HotSpot实战》的一段话
			“当我们阅读任何一个开源项目源代码时，核心目标都是去了解系统的运作原理，了解功能组件如何协作和发挥作用，那么我们的着眼点应当在于抓住数据结构这一核心，去了解功能的实现算法，而不是陷入编程语言的细节.数据结构的设计反映了功能组件的本质，从数据结构出发，可以了解组件在实现一个功能时，需要考虑哪些因素，是否依赖其他组件，需要设置哪些状态，是否提供优化措施等，数据结构包括结构体枚举，类和接口，它定义了数据成员，用以支撑算法（含功能性操作函数）的实现，而算法往往反映了功能的实现逻辑，因此从了解数据结构出发，结合算法的实现，便可以了解一个模块的具体作用，进而理解系统功能组件的实现原理”。
			其实我们在实现一个软件的时候也是围绕这两点，设计一个类也是围绕这两点，这里的 算法理解为处理逻辑，不要只以为复杂的处理逻辑是算法，简单的为什么
			不可以称为算法呢？
			数据结构可以直接体现系统从事的业务对象，例如实体映射的数据结构，自然不外乎表名，列名，列数据类型，长度，默认值，是否唯一，是否为空，是否索引
			其他的数据结构只是在不同组件进行传递的包装器类型。包装因为算法在处理流程中不可避免的产生中间对象，（这些中间对象是对用户隔离的）在算法复杂，系统层次较多时，这些中间数据结构要比直接用户输入（可以是参数，可以是注解，可以是整个类）的数据结构更加复杂，但是我们应该明白在面对这些数据结构的时候，应该更多的关注算法，此时是数据结构依赖于算法。而用户输入的产生的直接数据结构则是非常重要 ，他决定了算法。但是无论在分析的过程中更侧重谁，两者都相差不大，必须同时分析，相互对照。
			
			（敲黑板)回到我们的系统。
			核心数据结构是TableInfo,ColumnInfo这两个类的描述了表和列。但是这两个数据结构并不是用户直接的输入，而是我们在经过了用户配置文件解析，类加载，类解析（数据库解析）之后产生的数据结构在其后的生成表，数据操作（增删查改）提供缓存数据
			算法部分，实体类生成表分为几个处理阶段 
				1.读取xml配置文件，解析获取实体类的包名（StandardResourceConfig） //董浩
				2.加载指定包下的类，保存在映射（Map）中(StandardResourceLoader)  //杨开
				3. 解析指定包下的所有的类，这里的解析主要是指解析实体类上的所有注解，根据框架预定义的各个注解的使用规则，优先顺序
					冲突处理，将解析结果保存起来（ResourceResolver）(Resolver解析分解)//莹莹
				4. 数据库检查，我们做的是对象向数据库表定义的映射，当然需要在解析配置，//仁鹏
				   加载资源，解析分解完毕之后拿着我们解析到的结果跟数据库进行比较
				   这个比较的重任交给了DataBaseCheck以及他的两个内部类（TableCheck,ColumnCheck）,它主要负责检查表是否存在，列是否存在，列的定义是否不同（主要检查，是否主键，是否为空，是否不同，默认值，是否索引，数据类型，数据类型的长度等）
				   如何比较呢？需要调用JDBC的API,有直接调用即可返回结果的，有的需要混合使用。我所说的细节中有四分之一都在这里
				5. Sql语句生成
				   这是最简单的一层，也是最困难（细节太多）的一层，关键在于你怎么实现，
				   如果你想不负责任的实现，那么你就可以实现的简单一点点，如果你想负责任的实现，你一想到使用你框架的程序员，
				   因为你的愚蠢设计和编码不停地加班，而至于癫狂，就手脚发抖，如坐针毡，深深地愧疚，以至于日日焚香祷告，
				   还夜夜噩梦缠身，那么你就负责的实现,（负责的程序猿是宁可让自己癫狂，也不让代码的调用者有一丝烦恼的测试猿）
				   这个层主要由Generate接口负责，其下有很多实现类AlterColumnGenerate,AlterAddColumnGenerate,AlterColumnPrimaryKeyGenerate,TableGenerate
				   分别实现生成列修改语句，列添加语句，修改主键语句，表语句生成。
				6.执行生成的Sql语句，通过Statement执行
			容器启动部分：
				在第四步完成，容器也就算启动完毕。用户的数据库操作与具体的操作有关系，
				如插入操作分为获取记录各列的值，然后生成sql语句，然后执行
				删除操作  根据查询条件构造Sql语句，执行器执行删除
				更新操作  解析实体类，生成sql语句，执行器执行，更新实体类
				查询操作 根据用户输入可以选择输入查询条件与映射结果集，或者直接提供sql语句，以及结果集映射

	
   1.4版本不足及需要改进的地方：
		1.继续完善xml文件的定义，开发解析读取xml文件的工具包
		2.完善对视图映射的支持
   1.5 版本开发计划：
		1.增加监听器，对容器组件的生命周期，事件进行检测，实现核心启动代码与其他配置项启动解耦
		2.内部AOP，框架内部引入AOP，实现日志及其他业务无关逻辑与核心代码的解耦
		3.事务控制
			实现数据库操作安全性。
		4.数据库分表的支持，为用户提供默认的分表策略，及查询工具方法
		5.过滤器实现用户对数据库操作的灵活控制
	欢迎各位朋友提供想法与建议，更希望找有兴趣的小伙伴加入我们，一起开发，一起成长，一起开开心心的编程，最后感谢小伙伴们对我所做事情的帮助，认可，贡献，和你们的友谊是我每天开开心心的源动力。想起你们都是满满的幸福。